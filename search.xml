<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>分布式事务，解决方案</title>
    <url>/2019/12/06/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p><a href="http://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a><br><a href="https://blog.csdn.net/weixin_40533111/article/details/85069536" target="_blank" rel="noopener">分布式事务CAP理解论证-解决方案</a><br><a href="https://matt33.com/2018/07/08/distribute-system-consistency-protocol/" target="_blank" rel="noopener">分布式系统的2PC、3PC详细分析</a><br><a href="https://github.com/changmingxie/tcc-transaction" target="_blank" rel="noopener">github tcc示例</a><br><a href="https://juejin.im/post/5dda9e7e6fb9a07aae2a3778" target="_blank" rel="noopener">分布式事务、重复消费、顺序消费</a></p>
<h2 id="一、理论"><a href="#一、理论" class="headerlink" title="一、理论"></a>一、理论</h2><h3 id="CAP相关："><a href="#CAP相关：" class="headerlink" title="CAP相关："></a>CAP相关：</h3><p>CAP与BASE相关：<a href="https://wangyunzhong123.github.io/2019/12/01/%E5%88%86%E5%B8%83%E5%BC%8FCAP%E4%B8%8EBASE%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">我的博客</a></p>
<p>而对于分布式中的问题的解决方案,CAP原则出现,描述如下:</p>
<p>一致性(Consistency):</p>
<p>像A节点写入一条信息之后,同一时刻,在其他节点都可以读到这条信息</p>
<p>可用性(Availability):</p>
<p>多布一些节点A,B,C…,任何时刻,用户访问,都应该以可预期的结果返回,而不是浏览器报错,404,500,页面丢失…等用户体验不好的情况发生</p>
<p>分区容忍性(PartitionTolerance):</p>
<p>当各系统模块间通信出现问题时,设计一个策略,使系统仍可对外提供满足一致性或可用性</p>
<p>刚接触cap时,有些不理解分区容忍性,我们自己倒推一下:</p>
<ol>
<li>为了保证一致性,我们需要各个节点同步消息</li>
<li>为了保证可用性我们可以多部署节点,部分节点挂了仍可对外提供服务</li>
<li>为了保证分区容忍性:此刻卡壳了,怎么做?没了一种具体的方式,然而他还是客观存在的。后来发现:进入了思维盲点:只要在分布式场景中,分区必然存在,那么如果不处理分区发生时的情况,节点无法通讯时会发生什么?–此刻如果仍对外提供服务,那么导致无法同步消息,即保证不了强一致性;如果要保证强一致性,那么就需要节点阻塞,一直等待通讯恢复,即保证不了可用性.</li>
</ol>
<p>所以分区容忍性就是:当发生分区问题时,我们使用策略,在一致性和可用性二者间选择<br>注意: 无法通信包括网络问题,或者节点机器宕机</p>
<p>误区: CAP理论中说三者不可兼得,但实际情况是,在分布式场景中分区一定存在,即必须有分区容忍性对应的策略,之后才能在一致性和可用性间二者之间选择.所以对主流架构来说不是三选二,而是二选一。</p>
<h3 id="对P的理解"><a href="#对P的理解" class="headerlink" title="对P的理解"></a>对P的理解</h3><p>很多人可能对分区容忍性不太理解，知乎有一个回答对这个解释的比较清楚<a href="https://www.zhihu.com/question/54105974" target="_blank" rel="noopener">CAP理论中的P到底是个什么意思？</a>，这里引用一下：</p>
<ul>
<li>一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。</li>
<li>当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。</li>
<li>提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里，容忍性就提高了。</li>
<li>然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。</li>
<li>要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。</li>
<li>总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。</li>
</ul>
<h3 id="XA规范："><a href="#XA规范：" class="headerlink" title="XA规范："></a>XA规范：</h3><p><a href="http://www.jasongj.com/big_data/two_phase_commit/" target="_blank" rel="noopener">http://www.jasongj.com/big_data/two_phase_commit/</a><br><a href="https://www.cnblogs.com/zhoujinyi/p/5257558.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoujinyi/p/5257558.html</a></p>
<p>XA规范中，事务管理器主要通过以下的接口对资源管理器进行管理</p>
<ul>
<li>xa_open，xa_close：建立和关闭与资源管理器的连接。</li>
<li>xa_start，xa_end：开始和结束一个本地事务。</li>
<li>xa_prepare，xa_commit，xa_rollback：预提交、提交和回滚一个本地事务。</li>
<li>xa_recover：回滚一个已进行预提交的事务。</li>
</ul>
<p>XA规范：<a href="https://www.cnblogs.com/wt645631686/p/10882998.html" target="_blank" rel="noopener">https://www.cnblogs.com/wt645631686/p/10882998.html</a></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><a href="https://blog.csdn.net/weixin_40533111/article/details/85069536" target="_blank" rel="noopener">一些具体实现</a></p>
<ul>
<li>维护本地消息表</li>
<li>使用rocketmq事务消息：<a href="https://blog.csdn.net/weixin_40533111/article/details/84451219" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40533111/article/details/84451219</a></li>
<li>两阶段提交协议(2PC)</li>
<li>TCC事务补偿机制</li>
</ul>
<h4 id="使用限制："><a href="#使用限制：" class="headerlink" title="使用限制："></a>使用限制：</h4><p>a. XA事务和本地事务以及锁表操作是互斥的</p>
<p>开启了xa事务就无法使用本地事务和锁表操作:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; xa start &#39;t1xa&#39;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, 0 rows affected (0.04 sec)</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ERROR 1399 (XAE07): XAER_RMFAIL: The command cannot be executed when global transaction is in the ACTIVE state</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; lock table t1 read;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ERROR 1399 (XAE07): XAER_RMFAIL: The command cannot be executed when global transaction is in the ACTIVE state</span></pre></td></tr></table></figure>
<p>开启了本地事务就无法使用xa事务:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, 0 rows affected (0.00 sec)</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; xa start &#39;rrrr&#39;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ERROR 1400 (XAE09): XAER_OUTSIDE: Some work is done outside global transaction</span></pre></td></tr></table></figure>

<p>b. xa start 之后必须xa end， 否则不能执行xa commit 和xa rollback</p>
<p>所以如果在执行xa事务过程中有语句出错了，你也需要先xa end一下，然后才能xarollback。</p>
<p>注意事项:</p>
<p>a. mysql只是提供了xa事务的接口，分布式事务中的mysql实例之间是互相独立的不感知的。 所以用户必须<br>自己实现分布式事务的调度器<br>b. xa事务有一些使用上的bug， 参考<a href="http://www.mysqlops.com/2012/02/24/mysql-xa-optimize.html" target="_blank" rel="noopener">http://www.mysqlops.com/2012/02/24/mysql-xa-optimize.html</a></p>
<p>主要是:<br>“MySQL数据库的主备数据库的同步，通过Binlog的复制完成。而Binlog是MySQL数据库内部XA事务的协调者，并且MySQL数据库为binlog做了优化——binlog不写prepare日志，只写commit日志。<br>所有的参与节点prepare完成，在进行xa commit前crash。crash recover如果选择commit此事务。由于binlog在prepare阶段未写，因此主库中看来，此分布式事务最终提交了，但是此事务的操作并未 写到binlog中，因此也就未能成功复制到备库，从而导致主备库数据不一致的情况出现。<br>而crash recover如果选rollback, 那么就会出现全局不一致（该分布式事务对应的节点，部分已经提交，无法回滚，而部分节点回滚。最终导致同一分布式事务，在各参与节点，最终状态不一致）”</p>
<p>参考的那篇blog中给出的办法是修改mysql代码，这个无法在DBScale中使用。 所以可选的替代方案是不使用<br>主从复制进行备份，而是直接使用xa事务实现同步写来作为备份。</p>
<h2 id="二、两阶段提交2PC"><a href="#二、两阶段提交2PC" class="headerlink" title="二、两阶段提交2PC"></a>二、两阶段提交2PC</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p><img src="https://tvax3.sinaimg.cn/large/9ea5011cly1g9hg6hrqy1j20f308r74r.jpg" alt=""></p>
<p>两个角色：</p>
<ol>
<li>协调者</li>
<li>参与者</li>
</ol>
<p>两个阶段：</p>
<ol>
<li>阶段一：提交事务请求</li>
<li>阶段二：执行事务提交</li>
</ol>
<p>牺牲了一部分可用性来换取的一致性。解决方案有：springboot+Atomikos or Bitronix</p>
<p>优点： 原理简单，实现方便</p>
<p>缺点： </p>
<ol>
<li>同步阻塞：在提交的过程中，所有参与者都处于阻塞状态，大大降低并发度</li>
<li>单点问题：一旦协调者出现问题，则所有参与者处于锁定状态，无法对外服务</li>
<li>数据不一致：在阶段二，协调者发送了commit之后，发生了局部网络异常或者协调者尚未发送完commit请求就宕机了，导致部分参与者收到commit，导致系统出现不一致</li>
<li>太过保守：协调者在阶段一中，参与者出现故障而导致协调者无法获取到所有参与者的响应，协调者只能依靠超时时间来判断是否中断事务。换句话说，没有完善的容错机制。</li>
</ol>
<h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><p>JTA（Java Transaction API）定义了对XA事务的支持。像很多其他的Java规范一样，JTA仅仅定义了接口，具体的实现则是由供应商(如J2EE厂商)负责提供，目前JTA的实现主要有以下几种：</p>
<ul>
<li>J2EE容器所提供的JTA实现(如JBoss)。</li>
<li>独立的JTA实现：如JOTM（Java Open Transaction Manager），Atomikos。这些实现可以应用在那些不使用J2EE应用服务器的环境里用以提供分布事事务保证。</li>
</ul>
<p>MySQL中的XA实现分为：外部XA和内部XA。前者是指我们通常意义上的分布式事务实现；后者是指单台MySQL服务器中，Server层作为TM(事务协调者)，而服务器中的多个数据库实例作为RM，而进行的一种分布式事务，也就是MySQL跨库事务；也就是一个事务涉及到同一条MySQL服务器中的两个innodb数据库(因为其它引擎不支持XA)。</p>
<h2 id="三、三阶段提交3PC"><a href="#三、三阶段提交3PC" class="headerlink" title="三、三阶段提交3PC"></a>三、三阶段提交3PC</h2><p>是二阶段的改进版，将二阶段的提交事务请求过程一分为二，形成了：</p>
<ol>
<li>CanCommit：协调者发送事务询问、参与者反馈</li>
<li>PreCommit：协调者发送预提交请求、参与者事务预提交（执行事务操作，写undo、redo日志）、参与者响应</li>
<li>doCommit：协调者发送提交请求、参与者事务提交（事务提交，释放资源）、参与者响应</li>
</ol>
<p>在阶段二中，参与者可能会响应no，或者协调者等待超时时间后还无法收到所有参与者的反馈，则中断事务：协调者向所有参与者发送abort请求。参与者无论是收到协调者的abort请求，或者等待协调者请求过程中超时，都会中断事务。</p>
<p>在阶段三中，如果有任一参与者发送了no，或者等待超时后协调者还没收到所有参与者的反馈，则中断事务。需要注意的事，进入阶段三，可能会有下面两种故障：</p>
<ul>
<li>协调者出现问题</li>
<li>协调者、参与者之间的网络出现问题</li>
</ul>
<p>无论哪种情况，都会导致参与者无法及时收到来自协调者的doCommit或者abort请求，这种情况，参与者在等待超时后继续进行事务提交。</p>
<p>优点：</p>
<ol>
<li>降低了参与者的阻塞范围（二阶段中如果参与者与协调者断开，参与者abort；三阶段，提交），并且能够在单点故障后继续达成一致。</li>
</ol>
<p>缺点：</p>
<ol>
<li>参与者在收到preCommit后出现网络分区，参与者依然会提交事务，会造成不一致。</li>
</ol>
<h2 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h2><p>todo</p>
]]></content>
      <categories>
        <category>分布式 事务</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式CAP与BASE理论</title>
    <url>/2019/12/01/%E5%88%86%E5%B8%83%E5%BC%8FCAP%E4%B8%8EBASE%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="分布式Base理论"><a href="#分布式Base理论" class="headerlink" title="分布式Base理论"></a>分布式Base理论</h1><p>参考：<br><a href="https://my.oschina.net/foodon/blog/372703" target="_blank" rel="noopener">CAP和BASE理论</a><br><a href="https://juejin.im/post/5d720e86f265da03cc08de74" target="_blank" rel="noopener">https://juejin.im/post/5d720e86f265da03cc08de74</a><br><a href="https://github.com/changmingxie/tcc-transaction" target="_blank" rel="noopener">https://github.com/changmingxie/tcc-transaction</a><br>《从Paxos到Zookeeper》</p>
<h2 id="1-CAP理论"><a href="#1-CAP理论" class="headerlink" title="1. CAP理论"></a>1. CAP理论</h2><p>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。</p>
<p>CAP理论为：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p>
<h3 id="1-1-一致性（Consistency）"><a href="#1-1-一致性（Consistency）" class="headerlink" title="1.1 一致性（Consistency）"></a>1.1 一致性（Consistency）</h3><p>一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。</p>
<h3 id="1-2-可用性（Availability）"><a href="#1-2-可用性（Availability）" class="headerlink" title="1.2 可用性（Availability）"></a>1.2 可用性（Availability）</h3><p>可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。</p>
<h3 id="1-3-分区容错性（Partition-tolerance）"><a href="#1-3-分区容错性（Partition-tolerance）" class="headerlink" title="1.3 分区容错性（Partition tolerance）"></a>1.3 分区容错性（Partition tolerance）</h3><p>分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p>
<h2 id="2-CAP权衡"><a href="#2-CAP权衡" class="headerlink" title="2. CAP权衡"></a>2. CAP权衡</h2><p>通过CAP理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？</p>
<p>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。</p>
<p>对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CA，舍弃P。貌似这几年国内银行业发生了不下10起事故，但影响面不大，报到也不多，广大群众知道的少。还有一种是保证CP，舍弃A。例如网络故障事只读不写。</p>
<p>孰优孰略，没有定论，只能根据场景定夺，适合的才是最好的。</p>
<p>需要明确的一点是，对于一个分布式系统而言，分区容错性可以说是一个基本的要求。很简单，既然是分布式系统，则系统上的组件必然部署到不同的节点，必然出现子网络。</p>
<h2 id="3-BASE理论"><a href="#3-BASE理论" class="headerlink" title="3. BASE理论"></a>3. BASE理论</h2><p>Basical Available（基本可用）、Soft state（软状态）、Eventually consistent（最终一致性）</p>
<p>eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</p>
<p>BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。</p>
<h3 id="3-1-基本可用（Basically-Available）"><a href="#3-1-基本可用（Basically-Available）" class="headerlink" title="3.1 基本可用（Basically Available）"></a>3.1 基本可用（Basically Available）</h3><p>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。<br>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</p>
<p>两个体现：</p>
<ol>
<li>响应时间上的损失；更长了</li>
<li>功能上的损失；降级页面</li>
</ol>
<h3 id="3-2-软状态（-Soft-State）"><a href="#3-2-软状态（-Soft-State）" class="headerlink" title="3.2 软状态（ Soft State）"></a>3.2 软状态（ Soft State）</h3><p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。认为该中间状态不会影响系统的整体可用性。</p>
<h3 id="3-3-最终一致性（-Eventual-Consistency）"><a href="#3-3-最终一致性（-Eventual-Consistency）" class="headerlink" title="3.3 最终一致性（ Eventual Consistency）"></a>3.3 最终一致性（ Eventual Consistency）</h3><p>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p>
<h2 id="4-ACID和BASE的区别与联系"><a href="#4-ACID和BASE的区别与联系" class="headerlink" title="4. ACID和BASE的区别与联系"></a>4. ACID和BASE的区别与联系</h2><p>ACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。</p>
<p>在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用。</p>
]]></content>
      <categories>
        <category>分布式 事务</category>
      </categories>
  </entry>
  <entry>
    <title>冰雪奇缘2</title>
    <url>/2019/12/01/%E5%86%B0%E9%9B%AA%E5%A5%87%E7%BC%982/</url>
    <content><![CDATA[<h1 id="《冰雪奇缘2》"><a href="#《冰雪奇缘2》" class="headerlink" title="《冰雪奇缘2》"></a>《冰雪奇缘2》</h1><p>2019-11-23</p>
<p>在东湖渠华谊电影院。</p>
<p>9.0分。唯美公主梦</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
  </entry>
  <entry>
    <title>2019年冬第一场雪</title>
    <url>/2019/12/01/2019%E5%B9%B4%E5%86%AC%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%9B%AA/</url>
    <content><![CDATA[<p>雪：<br><img src="https://tva1.sinaimg.cn/large/9ea5011cly1g9hbzbztejj219i0pk7aq.jpg" alt="WechatIMG294"></p>
<p>晚霞：<br><img src="https://tvax3.sinaimg.cn/large/9ea5011cly1g9hby9depaj23402c0e81.jpg" alt="y5Jc3SqPTNGGE34sox59dA"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>雪</tag>
      </tags>
  </entry>
  <entry>
    <title>哆啦A梦伴我同行</title>
    <url>/2019/12/01/%E5%93%86%E5%95%A6A%E6%A2%A6%E4%BC%B4%E6%88%91%E5%90%8C%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="《哆啦A梦伴我同行》"><a href="#《哆啦A梦伴我同行》" class="headerlink" title="《哆啦A梦伴我同行》"></a>《哆啦A梦伴我同行》</h1><p>7.5</p>
<p>剧情较为单一。</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo、githubPages搭建博客</title>
    <url>/2019/12/01/%E4%BD%BF%E7%94%A8Hexo%E3%80%81githubPages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="使用hexo、github-Pages搭建博客"><a href="#使用hexo、github-Pages搭建博客" class="headerlink" title="使用hexo、github Pages搭建博客"></a>使用hexo、github Pages搭建博客</h1><h2 id="1-安装node"><a href="#1-安装node" class="headerlink" title="1. 安装node"></a>1. 安装node</h2><p>如果本机已经有node，为避免安装出现问题，建议先升级到最新版。参考：<a href="https://juejin.im/post/5b9739d1e51d450e9f66ee3b" target="_blank" rel="noopener">https://juejin.im/post/5b9739d1e51d450e9f66ee3b</a></p>
<h2 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2. 安装hexo"></a>2. 安装hexo</h2><p>参考：<a href="https://segmentfault.com/a/1190000017986794" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017986794</a></p>
<p>里面有图床、主题、评论配置。</p>
<h2 id="3-主题配置"><a href="#3-主题配置" class="headerlink" title="3. 主题配置"></a>3. 主题配置</h2><p>主题使用next的Pisces，具体可Google。</p>
<p>其中，原生的这个主题两边留白太多，现在很多都是宽屏，包括本人很喜欢宽屏展示。可以参考：调节next主题宽度 <a href="https://zuiyu1818.cn/posts/NexT_codewidth.html" target="_blank" rel="noopener">https://zuiyu1818.cn/posts/NexT_codewidth.html</a></p>
]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>工具 个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/2019/12/01/Java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h1><p>泛型：<a href="https://blog.csdn.net/briblue/article/details/76736356" target="_blank" rel="noopener">https://blog.csdn.net/briblue/article/details/76736356</a><br>《Effective Java中文版》<br>上下限通配符：<a href="https://www.cnblogs.com/alsf/p/5690052.html" target="_blank" rel="noopener">https://www.cnblogs.com/alsf/p/5690052.html</a> </p>
<h2 id="1-泛型类型"><a href="#1-泛型类型" class="headerlink" title="1. 泛型类型"></a>1. 泛型类型</h2><ol>
<li>泛型类。</li>
<li>泛型方法。</li>
<li>泛型接口。</li>
</ol>
<h2 id="2-原生态类型"><a href="#2-原生态类型" class="headerlink" title="2. 原生态类型"></a>2. 原生态类型</h2><p>List list = new ArrayList&lt;&gt;(); 就是原生态类型</p>
<h2 id="3-类型参数"><a href="#3-类型参数" class="headerlink" title="3. 类型参数"></a>3. 类型参数</h2><p>实例化、定义方法、定义接口的时候，传入的类型参数，一般用大写的字母表示；</p>
<p>List<E> {</p>
<p>}</p>
<h2 id="4-类型擦除"><a href="#4-类型擦除" class="headerlink" title="4. 类型擦除"></a>4. 类型擦除</h2><p>擦除就是使泛型可以与没有使用泛型的代码随意进行互用。</p>
<p>创建泛型、参数化类型或者类型参数的数组是非法的：</p>
<p>new List<E>[];<br>new List<String>[];<br>new E[];</p>
<p>都是非法的。</p>
<h2 id="5-通配符"><a href="#5-通配符" class="headerlink" title="5. 通配符"></a>5. 通配符</h2><p>除了用 <T>表示泛型外，还有 &lt;?&gt;这种形式。？ 被称为通配符。</p>
<p>Sub 是 Base 的子类，不代表 List<Sub>和 List<Base>有继承关系。<br>通配符的出现是为了指定泛型中的类型范围。</p>
<p>通配符有 3 种形式：</p>
<ol>
<li>&lt;?&gt;被称作无限定的通配符。</li>
<li>&lt;? extends T&gt;被称作有上限的通配符。</li>
<li>&lt;? super T&gt;被称作有下限的通配符。</li>
</ol>
<h3 id="5-1-无限定通配符"><a href="#5-1-无限定通配符" class="headerlink" title="5.1 无限定通配符"></a>5.1 无限定通配符</h3><p>如果使用“？“接收泛型对象的时候，则不能设置被泛型指定的内容。</p>
<h3 id="5-2-有上限通配符"><a href="#5-2-有上限通配符" class="headerlink" title="5.2 有上限通配符"></a>5.2 有上限通配符</h3><p>函数参数List&lt;? extends Parent&gt;，则传入参数的时候必须传入List<Parent>实例或者List&lt;Parent子类&gt;的实例。</p>
<h3 id="5-3-有下限通配符"><a href="#5-3-有下限通配符" class="headerlink" title="5.3 有下限通配符"></a>5.3 有下限通配符</h3><p>函数参数List&lt;? extends Sub&gt;，则传入参数的时候必须传入List<Sub>实例或者List&lt;Sub父类&gt;的实例。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 泛型</tag>
      </tags>
  </entry>
</search>
